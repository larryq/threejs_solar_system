{
  "version": 3,
  "sources": ["../../lamina/vanilla.js"],
  "sourcesContent": ["import * as THREE from 'three';\nimport { Color as Color$1, Vector3, Vector2, Vector4, Matrix3, Matrix4, Texture as Texture$1, MathUtils } from 'three';\nimport tokenize from 'glsl-tokenizer';\nimport descope from 'glsl-token-descope';\nimport stringify from 'glsl-token-string';\nimport tokenFunctions from 'glsl-token-functions';\nimport CustomShaderMaterial from 'three-custom-shader-material/vanilla';\n\nfunction getUniform(value) {\n  if (typeof value === 'string') {\n    return new Color$1(value).convertLinearToSRGB();\n  }\n\n  return value;\n}\nfunction getSpecialParameters(label) {\n  switch (label) {\n    case 'alpha':\n      return {\n        min: 0,\n        max: 1\n      };\n\n    case 'scale':\n      return {\n        min: 0\n      };\n\n    case 'map':\n      return {\n        image: undefined\n      };\n\n    default:\n      return {};\n  }\n}\nfunction isSerializableType(prop) {\n  return prop instanceof Vector3 || prop instanceof Vector2 || prop instanceof Vector4 || prop instanceof Matrix3 || prop instanceof Matrix4;\n}\nfunction serializeProp(prop) {\n  if (isSerializableType(prop)) {\n    return prop.toArray();\n  } else if (prop instanceof Color$1) {\n    return '#' + prop.clone().convertLinearToSRGB().getHexString();\n  } else if (prop instanceof Texture$1) {\n    return prop.image.src;\n  }\n\n  return prop;\n}\n\nconst BlendModes = {\n  normal: 'normal',\n  add: 'add',\n  subtract: 'subtract',\n  multiply: 'multiply',\n  lighten: 'lighten',\n  darken: 'darken',\n  divide: 'divide',\n  overlay: 'overlay',\n  screen: 'screen',\n  softlight: 'softlight',\n  negation: 'negation',\n  reflect: 'reflect'\n};\nconst NoiseTypes = {\n  perlin: 'perlin',\n  simplex: 'simplex',\n  cell: 'cell',\n  curl: 'curl',\n  white: 'white'\n};\nconst MappingTypes = {\n  local: 'local',\n  world: 'world',\n  uv: 'uv'\n};\nconst ShadingTypes = {\n  phong: THREE.MeshPhongMaterial,\n  physical: THREE.MeshPhysicalMaterial,\n  toon: THREE.MeshToonMaterial,\n  basic: THREE.MeshBasicMaterial,\n  lambert: THREE.MeshLambertMaterial,\n  standard: THREE.MeshStandardMaterial\n};\n\nclass Abstract {\n  constructor(c, props, onParse) {\n    this.uuid = MathUtils.generateUUID().replace(/-/g, '_');\n    this.name = 'LayerMaterial';\n    this.mode = 'normal';\n    this.visible = true;\n    const defaults = Object.getOwnPropertyNames(c).filter(e => e.startsWith('u_'));\n    const uniforms = defaults.reduce((a, v) => {\n      var _Object$getOwnPropert;\n\n      let value = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(c, v)) == null ? void 0 : _Object$getOwnPropert.value;\n      if (isSerializableType(value) || value instanceof Color$1) value = value.clone();\n      return { ...a,\n        [v.slice(1)]: value\n      };\n    }, {});\n\n    for (const key in uniforms) {\n      const propName = key.split('_')[1];\n      if ((props == null ? void 0 : props[propName]) !== undefined) uniforms[key] = props[propName];\n    }\n\n    if (props) {\n      Object.keys(props).map(key => {\n        if (props[key] !== undefined) {\n          // @ts-ignore\n          this[key] = props[key];\n        }\n      });\n    }\n\n    this.uniforms = {};\n    this.schema = [];\n    const properties = {};\n    Object.keys(uniforms).map(key => {\n      const propName = key.split('_')[1];\n      this.uniforms[`u_${this.uuid}_${propName}`] = {\n        value: getUniform(uniforms[key])\n      };\n      this.schema.push({\n        value: uniforms[key],\n        label: propName\n      });\n      properties[propName] = {\n        set: v => {\n          this.uniforms[`u_${this.uuid}_${propName}`].value = getUniform(v);\n        },\n        get: () => {\n          return this.uniforms[`u_${this.uuid}_${propName}`].value;\n        }\n      };\n    });\n    if (props != null && props.name) this.name = props.name;\n    if (props != null && props.mode) this.mode = props.mode;\n    if (props != null && props.visible) this.visible = props.visible;\n    Object.defineProperties(this, properties);\n    this.vertexShader = '';\n    this.fragmentShader = '';\n    this.vertexVariables = '';\n    this.fragmentVariables = '';\n    this.onParse = onParse;\n    this.buildShaders(c); // Remove Name field from Debugger until a way to\n    // rename Leva folders is found\n    // this.schema.push({\n    //   value: this.name,\n    //   label: 'name',\n    // })\n\n    this.schema.push({\n      value: this.mode,\n      label: 'mode',\n      options: Object.values(BlendModes)\n    });\n    this.schema.push({\n      value: this.visible,\n      label: 'visible'\n    });\n  }\n\n  buildShaders(constructor) {\n    var _this$onParse;\n\n    const shaders = Object.getOwnPropertyNames(constructor).filter(e => e === 'fragmentShader' || e === 'vertexShader').reduce((a, v) => {\n      var _Object$getOwnPropert2;\n\n      return { ...a,\n        [v]: (_Object$getOwnPropert2 = Object.getOwnPropertyDescriptor(constructor, v)) == null ? void 0 : _Object$getOwnPropert2.value\n      };\n    }, {});\n    const tokens = {\n      vert: tokenize(shaders.vertexShader || ''),\n      frag: tokenize(shaders.fragmentShader || '')\n    };\n    const descoped = {\n      vert: descope(tokens.vert, this.renameTokens.bind(this)),\n      frag: descope(tokens.frag, this.renameTokens.bind(this))\n    };\n    const funcs = {\n      vert: tokenFunctions(descoped.vert),\n      frag: tokenFunctions(descoped.frag)\n    };\n    const mainIndex = {\n      vert: funcs.vert.map(e => {\n        return e.name;\n      }).indexOf('main'),\n      frag: funcs.frag.map(e => {\n        return e.name;\n      }).indexOf('main')\n    };\n    const variables = {\n      vert: mainIndex.vert >= 0 ? stringify(descoped.vert.slice(0, funcs.vert[mainIndex.vert].outer[0])) : '',\n      frag: mainIndex.frag >= 0 ? stringify(descoped.frag.slice(0, funcs.frag[mainIndex.frag].outer[0])) : ''\n    };\n    const funcBodies = {\n      vert: mainIndex.vert >= 0 ? this.getShaderFromIndex(descoped.vert, funcs.vert[mainIndex.vert].body) : '',\n      frag: mainIndex.frag >= 0 ? this.getShaderFromIndex(descoped.frag, funcs.frag[mainIndex.frag].body) : ''\n    };\n    this.vertexShader = this.processFinal(funcBodies.vert, true);\n    this.fragmentShader = this.processFinal(funcBodies.frag);\n    this.vertexVariables = variables.vert;\n    this.fragmentVariables = variables.frag;\n    (_this$onParse = this.onParse) == null ? void 0 : _this$onParse.call(this, this);\n    this.schema = this.schema.filter((value, index) => {\n      const _value = value.label;\n      return index === this.schema.findIndex(obj => {\n        return obj.label === _value;\n      });\n    });\n  }\n\n  renameTokens(name) {\n    if (name.startsWith('u_')) {\n      const slice = name.slice(2);\n      return `u_${this.uuid}_${slice}`;\n    } else if (name.startsWith('v_')) {\n      const slice = name.slice(2);\n      return `v_${this.uuid}_${slice}`;\n    } else if (name.startsWith('f_')) {\n      const slice = name.slice(2);\n      return `f_${this.uuid}_${slice}`;\n    } else {\n      return name;\n    }\n  }\n\n  processFinal(shader, isVertex) {\n    const s = shader.replace(/\\sf_/gm, ` f_${this.uuid}_`).replace(/\\(f_/gm, `(f_${this.uuid}_`);\n    const returnValue = s.match(/^.*return.*$/gm);\n    let sReplaced = s.replace(/^.*return.*$/gm, '');\n\n    if (returnValue != null && returnValue[0]) {\n      const returnVariable = returnValue[0].replace('return', '').trim().replace(';', '');\n      const blendMode = this.getBlendMode(returnVariable, 'lamina_finalColor');\n      sReplaced += isVertex ? `lamina_finalPosition = ${returnVariable};` : `lamina_finalColor = ${blendMode};`;\n    }\n\n    return sReplaced;\n  }\n\n  getShaderFromIndex(tokens, index) {\n    return stringify(tokens.slice(index[0], index[1]));\n  }\n\n  getBlendMode(b, a) {\n    switch (this.mode) {\n      default:\n      case 'normal':\n        return `lamina_blend_alpha(${a}, ${b}, ${b}.a)`;\n\n      case 'add':\n        return `lamina_blend_add(${a}, ${b}, ${b}.a)`;\n\n      case 'subtract':\n        return `lamina_blend_subtract(${a}, ${b}, ${b}.a)`;\n\n      case 'multiply':\n        return `lamina_blend_multiply(${a}, ${b}, ${b}.a)`;\n\n      case 'lighten':\n        return `lamina_blend_lighten(${a}, ${b}, ${b}.a)`;\n\n      case 'darken':\n        return `lamina_blend_darken(${a}, ${b}, ${b}.a)`;\n\n      case 'divide':\n        return `lamina_blend_divide(${a}, ${b}, ${b}.a)`;\n\n      case 'overlay':\n        return `lamina_blend_overlay(${a}, ${b}, ${b}.a)`;\n\n      case 'screen':\n        return `lamina_blend_screen(${a}, ${b}, ${b}.a)`;\n\n      case 'softlight':\n        return `lamina_blend_softlight(${a}, ${b}, ${b}.a)`;\n\n      case 'reflect':\n        return `lamina_blend_reflect(${a}, ${b}, ${b}.a)`;\n\n      case 'negation':\n        return `lamina_blend_negation(${a}, ${b}, ${b}.a)`;\n    }\n  }\n\n  getSchema() {\n    const latestSchema = this.schema.map(({\n      label,\n      options,\n      ...rest\n    }) => {\n      return {\n        label,\n        options,\n        ...getSpecialParameters(label),\n        ...rest,\n        // @ts-ignore\n        value: serializeProp(this[label])\n      };\n    });\n    return latestSchema;\n  }\n\n  serialize() {\n    const name = this.constructor.name.split('$')[0];\n    let nonUniformPropKeys = Object.keys(this);\n    nonUniformPropKeys = nonUniformPropKeys.filter(e => !['uuid', 'uniforms', 'schema', 'fragmentShader', 'vertexShader', 'fragmentVariables', 'vertexVariables', 'attribs', 'events', '__r3f', 'onParse'].includes(e));\n    const nonUniformProps = {};\n    nonUniformPropKeys.forEach(k => {\n      // @ts-ignore\n      nonUniformProps[k] = this[k];\n    });\n    const props = {};\n\n    for (const key in this.uniforms) {\n      const name = key.replace(`u_${this.uuid}_`, '');\n      props[name] = serializeProp(this.uniforms[key].value);\n    }\n\n    return {\n      constructor: name,\n      properties: { ...props,\n        ...nonUniformProps\n      }\n    };\n  }\n\n}\n\nclass Depth extends Abstract {\n  constructor(props) {\n    super(Depth, {\n      name: 'Depth',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: ['vector', 'world', 'camera']\n      });\n      const mapping = Depth.getMapping(self.uuid, self.mapping);\n      self.fragmentShader = self.fragmentShader.replace('lamina_mapping_template', mapping);\n    });\n    this.mapping = 'vector';\n  }\n\n  static getMapping(uuid, type) {\n    switch (type) {\n      default:\n      case 'vector':\n        return `length(v_${uuid}_worldPosition - u_${uuid}_origin)`;\n\n      case 'world':\n        return `length(v_${uuid}_position - vec3(0.))`;\n\n      case 'camera':\n        return `length(v_${uuid}_worldPosition - cameraPosition)`;\n    }\n  }\n\n}\nDepth.u_near = 2;\nDepth.u_far = 10;\nDepth.u_origin = new Vector3(0, 0, 0);\nDepth.u_colorA = 'white';\nDepth.u_colorB = 'black';\nDepth.u_alpha = 1;\nDepth.vertexShader = `\n  varying vec3 v_worldPosition;\n  varying vec3 v_position;\n\n  void main() {\n    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;\n    v_position = position;\n  }\n  `;\nDepth.fragmentShader = `   \n    uniform float u_alpha;\n    uniform float u_near;\n    uniform float u_far;\n    uniform float u_isVector;\n    uniform vec3 u_origin;\n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_position;\n\n    void main() {\n      float f_dist = lamina_mapping_template;\n      float f_depth = (f_dist - u_near) / (u_far - u_near);\n\t\t\tvec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));\n  \n  \n      return vec4(f_depthColor, u_alpha);\n    }\n  `;\n\nclass Color extends Abstract {\n  constructor(props) {\n    super(Color, {\n      name: 'Color',\n      ...props\n    });\n  }\n\n}\nColor.u_color = 'red';\nColor.u_alpha = 1;\nColor.fragmentShader = `   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n\n    void main() {\n      return vec4(u_color, u_alpha);\n    }\n  `;\n\nclass Noise extends Abstract {\n  constructor(props) {\n    super(Noise, {\n      name: 'noise',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.type,\n        label: 'type',\n        options: Object.values(NoiseTypes)\n      });\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: Object.values(MappingTypes)\n      });\n      const noiseFunc = Noise.getNoiseFunction(self.type);\n      const mapping = Noise.getMapping(self.mapping);\n      self.vertexShader = self.vertexShader.replace('lamina_mapping_template', mapping);\n      self.fragmentShader = self.fragmentShader.replace('lamina_noise_template', noiseFunc);\n    });\n    this.type = 'perlin';\n    this.mapping = 'local';\n  }\n\n  static getNoiseFunction(type) {\n    switch (type) {\n      default:\n      case 'perlin':\n        return `lamina_noise_perlin`;\n\n      case 'simplex':\n        return `lamina_noise_simplex`;\n\n      case 'cell':\n        return `lamina_noise_worley`;\n\n      case 'white':\n        return `lamina_noise_white`;\n\n      case 'curl':\n        return `lamina_noise_swirl`;\n    }\n  }\n\n  static getMapping(type) {\n    switch (type) {\n      default:\n      case 'local':\n        return `position`;\n\n      case 'world':\n        return `(modelMatrix * vec4(position,1.0)).xyz`;\n\n      case 'uv':\n        return `vec3(uv, 0.)`;\n    }\n  }\n\n}\nNoise.u_colorA = '#666666';\nNoise.u_colorB = '#666666';\nNoise.u_colorC = '#FFFFFF';\nNoise.u_colorD = '#FFFFFF';\nNoise.u_alpha = 1;\nNoise.u_scale = 1;\nNoise.u_offset = new Vector3(0, 0, 0);\nNoise.vertexShader = `\n    varying vec3 v_position;\n\n    void main() {\n        v_position = lamina_mapping_template;\n    }\n  `;\nNoise.fragmentShader = `   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_colorC;\n    uniform vec3 u_colorD;\n    uniform vec3 u_offset;\n\n    uniform float u_alpha;\n    uniform float u_scale;\n\n    varying vec3 v_position;\n\n\n    void main() {\n        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);\n\n        float f_step1 = 0.;\n        float f_step2 = 0.2;\n        float f_step3 = 0.6;\n        float f_step4 = 1.;\n\n        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));\n        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));\n        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));\n\n        return vec4(f_color, u_alpha);\n    }\n  `;\n\nclass Fresnel extends Abstract {\n  constructor(props) {\n    super(Fresnel, {\n      name: 'Fresnel',\n      ...props\n    });\n  }\n\n}\nFresnel.u_color = 'white';\nFresnel.u_alpha = 1;\nFresnel.u_bias = 0;\nFresnel.u_intensity = 1;\nFresnel.u_power = 2;\nFresnel.u_factor = 1;\nFresnel.vertexShader = `\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);\n        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n        \n    }\n  `;\nFresnel.fragmentShader = `   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n    uniform float u_bias;\n    uniform float u_intensity;\n    uniform float u_power;\n    uniform float u_factor;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));\n        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);\n\n        f_fresnel = clamp(f_fresnel, 0.0, 1.0);\n        return vec4(f_fresnel * u_color, u_alpha);\n    }\n  `;\n\nclass Gradient extends Abstract {\n  constructor(props) {\n    super(Gradient, {\n      name: 'Gradient',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.axes,\n        label: 'axes',\n        options: ['x', 'y', 'z']\n      });\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: Object.values(MappingTypes)\n      });\n      const mapping = Gradient.getMapping(self.mapping);\n      self.vertexShader = self.vertexShader.replace('lamina_mapping_template', mapping || 'local');\n      self.fragmentShader = self.fragmentShader.replace('axes_template', self.axes || 'x');\n    });\n    this.axes = 'x';\n    this.mapping = 'local';\n  }\n\n  static getMapping(type) {\n    switch (type) {\n      default:\n      case 'local':\n        return `position`;\n\n      case 'world':\n        return `(modelMatrix * vec4(position,1.0)).xyz`;\n\n      case 'uv':\n        return `vec3(uv, 0.)`;\n    }\n  }\n\n}\nGradient.u_colorA = 'white';\nGradient.u_colorB = 'black';\nGradient.u_alpha = 1;\nGradient.u_start = 1;\nGradient.u_end = -1;\nGradient.u_contrast = 1;\nGradient.vertexShader = `\n\t\tvarying vec3 v_position;\n\n\t\tvod main() {\n      v_position = lamina_mapping_template;\n\t\t}\n  `;\nGradient.fragmentShader = `   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_axis;\n    uniform float u_alpha;\n    uniform float u_start;\n    uniform float u_end;\n    uniform float u_contrast;\n\n\t\tvarying vec3 v_position;\n\n    void main() {\n\n      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);\n      vec3 f_color = mix(u_colorA, u_colorB, f_step);\n\n      return vec4(f_color, u_alpha);\n    }\n  `;\n\nclass Matcap extends Abstract {\n  constructor(props) {\n    super(Matcap, {\n      name: \"Matcap\",\n      ...props\n    });\n  }\n\n}\nMatcap.u_alpha = 1;\nMatcap.u_map = undefined;\nMatcap.vertexShader = `\n    varying vec3 v_position;\n    varying vec3 v_normal;\n    \n    void main() {\n      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\n      v_normal = normalize( normalMatrix * normal );\n    }\n    `;\nMatcap.fragmentShader = ` \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec3 v_position;\n\t\tvarying vec3 v_normal;\n\n\t\t\n    void main() {\n\t\t\tvec3 f_r = reflect( v_position, v_normal );\n\t\t\tfloat f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );\n\t\t\tvec2 f_vN = f_r.xy / f_m + .5;\n\n\t\t\tvec3 f_base = texture2D(u_map, f_vN).rgb;\n\n      return vec4(f_base, u_alpha);\n    }\n  `;\n\nclass Texture extends Abstract {\n  constructor(props) {\n    super(Texture, {\n      name: 'Texture',\n      ...props\n    });\n  }\n\n}\nTexture.u_alpha = 1;\nTexture.u_map = undefined;\nTexture.vertexShader = `\n    varying vec2 v_uv;\n    \n    void main() {\n        v_uv = uv;\n    }\n    `;\nTexture.fragmentShader = ` \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec2 v_uv;\n\n    void main() {\n\t\t\tvec4 f_color = texture2D(u_map, v_uv);\n      return vec4(f_color.rgb, f_color.a * u_alpha);\n    }\n  `;\n\nclass Displace extends Abstract {\n  constructor(props) {\n    super(Displace, {\n      name: 'Displace',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.type,\n        label: 'type',\n        options: Object.values(NoiseTypes)\n      });\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: Object.values(MappingTypes)\n      });\n      const noiseFunc = Displace.getNoiseFunction(self.type);\n      const mapping = Displace.getMapping(self.mapping);\n      self.vertexVariables = self.vertexVariables.replace('lamina_mapping_template', mapping);\n      self.vertexVariables = self.vertexVariables.replace('lamina_noise_template', noiseFunc);\n    });\n    this.type = 'perlin';\n    this.mapping = 'local';\n  }\n\n  static getNoiseFunction(type) {\n    switch (type) {\n      default:\n      case 'perlin':\n        return `lamina_noise_perlin`;\n\n      case 'simplex':\n        return `lamina_noise_simplex`;\n\n      case 'cell':\n        return `lamina_noise_worley`;\n\n      case 'white':\n        return `lamina_noise_white`;\n\n      case 'curl':\n        return `lamina_noise_swirl`;\n    }\n  }\n\n  static getMapping(type) {\n    switch (type) {\n      default:\n      case 'local':\n        return `p`;\n\n      case 'world':\n        return `(modelMatrix * vec4(p,1.0)).xyz`;\n\n      case 'uv':\n        return `vec3(uv, 0.)`;\n    }\n  }\n\n}\nDisplace.u_strength = 1;\nDisplace.u_scale = 1;\nDisplace.u_offset = new Vector3(0, 0, 0);\nDisplace.vertexShader = `\n       \n      uniform float u_strength;\n      uniform float u_scale;\n      uniform vec3 u_offset;\n\n      vec3 displace(vec3 p) {\n\t\t\t\tvec3 f_position = lamina_mapping_template;\n        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;\n        vec3 f_newPosition = p + (f_n * normal);\n\n\t\t\t\treturn f_newPosition;\n      }\n\n      \n\t\t\tvec3 orthogonal(vec3 v) {\n  \t\t  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  \t\t  : vec3(0.0, -v.z, v.y));\n  \t\t}\n  \t\tvec3 recalcNormals(vec3 newPos) {\n  \t\t  float offset = 0.001;\n  \t\t  vec3 tangent = orthogonal(normal);\n  \t\t  vec3 bitangent = normalize(cross(normal, tangent));\n  \t\t  vec3 neighbour1 = position + tangent * offset;\n  \t\t  vec3 neighbour2 = position + bitangent * offset;\n  \t\t  vec3 displacedNeighbour1 = displace(neighbour1);\n  \t\t  vec3 displacedNeighbour2 = displace(neighbour2);\n  \t\t  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  \t\t  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n  \t\t  return normalize(cross(displacedTangent, displacedBitangent));\n  \t\t}\n  \n  \n      void main() {\n       \n\t\t\t\tvec3 f_newPosition = displace(position);\n        lamina_finalNormal = recalcNormals(f_newPosition);\n\n        return f_newPosition;\n      }\n    `;\n\nclass Normal extends Abstract {\n  constructor(props) {\n    super(Normal, {\n      name: 'Normal',\n      ...props\n    });\n  }\n\n}\nNormal.u_alpha = 1;\nNormal.u_direction = new Vector3(1, 1, 1);\nNormal.vertexShader = `   \n  varying vec3 v_normals; \n\n  void main() {\n    v_normals = normal;\n  }\n`;\nNormal.fragmentShader = `   \n  \tuniform float u_alpha;\n  \tuniform vec3 u_color;\n  \tuniform vec3 u_direction;\n\n\t\tvarying vec3 v_normals;\n\n    void main() {\n\t\t\tvec3 f_normalColor = vec3(1.);\n      f_normalColor.x = v_normals.x * u_direction.x;\n      f_normalColor.y = v_normals.y * u_direction.y;\n      f_normalColor.z = v_normals.z * u_direction.z;\n\n      return vec4(f_normalColor, u_alpha);\n    }\n  `;\n\nvar BlendModesChunk = /* glsl */\n`\nvec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(min(x.xyz + y.xyz, 1.0) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {\n\n\treturn y * opacity + x * (1.0 - opacity);\n\n}\n\nvec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tfloat a = min(y.a, opacity);\n\n\treturn vec4(lamina_blend_alpha(x.rgb, y.rgb, a), x.a);\n\n}\nvec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((x.xyz + y.xyz) * 0.5 * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_color_burn(const in float x, const in float y) {\n\n\treturn (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\n\n}\n\nvec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_burn(x.r, y.r),\n\t\tlamina_blend_color_burn(x.g, y.g),\n\t\tlamina_blend_color_burn(x.b, y.b),\n\t\tlamina_blend_color_burn(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_color_dodge(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_dodge(x.r, y.r),\n\t\tlamina_blend_color_dodge(x.g, y.g),\n\t\tlamina_blend_color_dodge(x.b, y.b),\n\t\tlamina_blend_color_dodge(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(min(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(abs(x.xyz - y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_divide(const in float x, const in float y) {\n\n\treturn (y > 0.0) ? min(x / y, 1.0) : 1.0;\n\n}\n\nvec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_divide(x.r, y.r),\n\t\tlamina_blend_divide(x.g, y.g),\n\t\tlamina_blend_divide(x.b, y.b),\n\t\tlamina_blend_divide(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((x.xyz + y.xyz - 2.0 * x.xyz * y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(max(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4( x.xyz * y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((1.0 - abs(1.0 - x.xyz - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_overlay(const in float x, const in float y) {\n\n\treturn (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\n\n}\n\nvec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_overlay(x.r, y.r),\n\t\tlamina_blend_overlay(x.g, y.g),\n\t\tlamina_blend_overlay(x.b, y.b),\n\t\tlamina_blend_overlay(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_reflect(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_reflect(x.r, y.r),\n\t\tlamina_blend_reflect(x.g, y.g),\n\t\tlamina_blend_reflect(x.b, y.b),\n\t\tlamina_blend_reflect(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4((1.0 - (1.0 - x.xyz) * (1.0 - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_softlight(const in float x, const in float y) {\n\n\treturn (y < 0.5) ?\n\t\t(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\n\t\t(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\n\n}\n\nvec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_softlight(x.r, y.r),\n\t\tlamina_blend_softlight(x.g, y.g),\n\t\tlamina_blend_softlight(x.b, y.b),\n\t\tlamina_blend_softlight(x.a, y.a)\n\t);\n\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn vec4(max(x.xyz + y.xyz - 1.0, 0.0) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\n\n`;\n\nvar NoiseChunk = /* glsl */\n`\n\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Huge thanks to the creators of these algorithms\n\nfloat lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}\nvec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat lamina_noise_white(vec2 p) {\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat lamina_noise_white(vec3 p) {\n  return lamina_noise_white(p.xy);\n}\n\n\nvec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat lamina_noise_perlin(vec3 P) {\n  vec3 Pi0 = floor(P);        // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);\n  vec4 ixy0 = lamina_noise_permute(ixy + iz0);\n  vec4 ixy1 = lamina_noise_permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = lamina_noise_fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return lamina_normalize(2.2 * n_xyz);\n}\n\nfloat lamina_noise_simplex(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n  i = mod(i, 289.0);\n  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                             vec4(0.0, i1.y, i2.y, 1.0)) +\n                    i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0 / 7.0; // N=7\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return lamina_normalize(42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));\n}\n\nvec3 lamina_noise_simplex3(vec3 x) {\n  float s = lamina_noise_simplex(vec3(x));\n  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n  vec3 c = vec3(s, s1, s2);\n  return c;\n}\n\nvec3 lamina_noise_curl(vec3 p) {\n  const float e = .1;\n  vec3 dx = vec3(e, 0.0, 0.0);\n  vec3 dy = vec3(0.0, e, 0.0);\n  vec3 dz = vec3(0.0, 0.0, e);\n\n  vec3 p_x0 = lamina_noise_simplex3(p - dx);\n  vec3 p_x1 = lamina_noise_simplex3(p + dx);\n  vec3 p_y0 = lamina_noise_simplex3(p - dy);\n  vec3 p_y1 = lamina_noise_simplex3(p + dy);\n  vec3 p_z0 = lamina_noise_simplex3(p - dz);\n  vec3 p_z1 = lamina_noise_simplex3(p + dz);\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / (2.0 * e);\n  return normalize(vec3(x, y, z) * divisor);\n}\n\nvec3 lamina_permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\n// From: https://github.com/Erkaman/glsl-worley\nfloat lamina_noise_worley(vec3 P) {\n  float jitter = 1.;\n  bool manhattanDistance = false; \n\n  float K = 0.142857142857; // 1/7\n  float Ko = 0.428571428571; // 1/2-K/2\n  float  K2 = 0.020408163265306; // 1/(7*7)\n  float Kz = 0.166666666667; // 1/6\n  float Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = lamina_permute(p + Pi.y - 1.0);\n\tvec3 p2 = lamina_permute(p + Pi.y);\n\tvec3 p3 = lamina_permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = lamina_permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = lamina_permute(p1 + Pi.z);\n\tvec3 p13 = lamina_permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = lamina_permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = lamina_permute(p2 + Pi.z);\n\tvec3 p23 = lamina_permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = lamina_permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = lamina_permute(p3 + Pi.z);\n\tvec3 p33 = lamina_permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\n  vec2 F = sqrt(d11.xy);\n\treturn F.x; // F1, F2\n\n}\n\nfloat lamina_noise_swirl(vec3 position) {\n    float scale = 0.1;\n    float freq = 4. * scale;\n    float t = 1.;\n\n    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);\n\n    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));\n    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));\n    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));\n    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));\n    \n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n\n    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);\n    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + \n        curlWorleyFbm.b * .125;\n\n    return curlWorley;\n}\n  \n  \n`;\n\nvar HelpersChunk = /* glsl */\n`\n\nfloat lamina_map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }\n`;\n\nclass LayerMaterial extends CustomShaderMaterial {\n  constructor({\n    color,\n    alpha,\n    lighting,\n    layers,\n    name,\n    ...props\n  } = {}) {\n    super({\n      baseMaterial: ShadingTypes[lighting || 'basic'],\n      ...props\n    });\n    this.name = 'LayerMaterial';\n    this.layers = [];\n    this.lighting = 'basic';\n\n    const _baseColor = color || 'white';\n\n    const _alpha = alpha != null ? alpha : 1;\n\n    this.uniforms = {\n      u_lamina_color: {\n        value: typeof _baseColor === 'string' ? new THREE.Color(_baseColor).convertSRGBToLinear() : _baseColor\n      },\n      u_lamina_alpha: {\n        value: _alpha\n      }\n    };\n    this.layers = layers || this.layers;\n    this.lighting = lighting || this.lighting;\n    this.name = name || this.name;\n    this.refresh();\n  }\n\n  genShaders() {\n    let vertexVariables = '';\n    let fragmentVariables = '';\n    let vertexShader = '';\n    let fragmentShader = '';\n    let uniforms = {};\n    this.layers.filter(l => l.visible).forEach(l => {\n      // l.buildShaders(l.constructor)\n      vertexVariables += l.vertexVariables + '\\n';\n      fragmentVariables += l.fragmentVariables + '\\n';\n      vertexShader += l.vertexShader + '\\n';\n      fragmentShader += l.fragmentShader + '\\n';\n      uniforms = { ...uniforms,\n        ...l.uniforms\n      };\n    });\n    uniforms = { ...uniforms,\n      ...this.uniforms\n    };\n    return {\n      uniforms,\n      vertexShader: `\n        ${HelpersChunk}\n        ${NoiseChunk}\n        ${vertexVariables}\n\n        void main() {\n          vec3 lamina_finalPosition = position;\n          vec3 lamina_finalNormal = normal;\n\n          ${vertexShader}\n\n          csm_Position = lamina_finalPosition;\n          csm_Normal = lamina_finalNormal;\n        }\n        `,\n      fragmentShader: `\n        ${HelpersChunk}\n        ${NoiseChunk}\n        ${BlendModesChunk}\n        ${fragmentVariables}\n\n        uniform vec3 u_lamina_color;\n        uniform float u_lamina_alpha;\n\n        void main() {\n          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);\n\n          ${fragmentShader}\n\n          csm_DiffuseColor = lamina_finalColor;\n         \n        }\n        `\n    };\n  }\n\n  refresh() {\n    const {\n      uniforms,\n      fragmentShader,\n      vertexShader\n    } = this.genShaders();\n    super.update({\n      fragmentShader,\n      vertexShader,\n      uniforms\n    });\n  }\n\n  serialize() {\n    return {\n      constructor: 'LayerMaterial',\n      properties: {\n        color: this.color,\n        alpha: this.alpha,\n        name: this.name,\n        lighting: this.lighting\n      }\n    };\n  }\n\n  set color(v) {\n    var _this$uniforms, _this$uniforms$u_lami;\n\n    if ((_this$uniforms = this.uniforms) != null && (_this$uniforms$u_lami = _this$uniforms.u_lamina_color) != null && _this$uniforms$u_lami.value) this.uniforms.u_lamina_color.value = typeof v === 'string' ? new THREE.Color(v).convertSRGBToLinear() : v;\n  }\n\n  get color() {\n    var _this$uniforms2, _this$uniforms2$u_lam;\n\n    return (_this$uniforms2 = this.uniforms) == null ? void 0 : (_this$uniforms2$u_lam = _this$uniforms2.u_lamina_color) == null ? void 0 : _this$uniforms2$u_lam.value;\n  }\n\n  set alpha(v) {\n    this.uniforms.u_lamina_alpha.value = v;\n  }\n\n  get alpha() {\n    return this.uniforms.u_lamina_alpha.value;\n  }\n\n}\n\nexport { Abstract, Color, Depth, Displace, Fresnel, Gradient, LayerMaterial, Matcap, Noise, Normal, Texture };\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsLA,IAAI;AAAA;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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",
  "names": ["tokenize", "descope", "tokenFunctions", "stringify", "name", "Color", "Texture"]
}
